// app/api/vendor-audio/route.js
import { NextResponse } from 'next/server';

export const runtime = 'nodejs'; // ensure Node runtime for file handling

// 10 MB in bytes
const MAX_BYTES = 10 * 1024 * 1024;
const ALLOWED_MIME = new Set(['audio/mpeg', 'audio/mp3']);

const GRAPH = 'https://graph.microsoft.com/v1.0';
const TOKEN_URL = (tenant) =>
  `https://login.microsoftonline.com/${tenant}/oauth2/v2.0/token`;

async function getGraphToken() {
  const res = await fetch(TOKEN_URL(process.env.MS_TENANT_ID), {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({
      client_id: process.env.MS_CLIENT_ID,
      client_secret: process.env.MS_CLIENT_SECRET,
      scope: 'https://graph.microsoft.com/.default',
      grant_type: 'client_credentials',
    }),
    cache: 'no-store',
  });
  if (!res.ok) {
    const t = await res.text();
    throw new Error(`Token error ${res.status}: ${t}`);
  }
  return res.json();
}

function safeSegment(name) {
  return (name || 'Unknown')
    .replace(/[\\/:"*?<>|]+/g, '-') // remove illegal path chars
    .replace(/\s+/g, ' ')
    .trim()
    .slice(0, 80);
}

async function ensureFolderPath(accessToken, driveId, path) {
  // Incrementally create: Vendors/VendorName/Recordings/YYYY-MM
  const parts = path.split('/').filter(Boolean);
  let cursorId = 'root';

  for (const raw of parts) {
    const part = safeSegment(raw);

    // List current children
    const listRes = await fetch(
      `${GRAPH}/drives/${driveId}/items/${cursorId}/children?$select=id,name,folder`,
      { headers: { Authorization: `Bearer ${accessToken}` }, cache: 'no-store' }
    );
    if (!listRes.ok) throw new Error(`List children failed: ${await listRes.text()}`);
    const list = await listRes.json();
    const existing = (list.value || []).find((i) => i.name === part && i.folder);

    if (existing) {
      cursorId = existing.id;
      continue;
    }

    // Create folder
    const createRes = await fetch(`${GRAPH}/drives/${driveId}/items/${cursorId}/children`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        name: part,
        folder: {},
        '@microsoft.graph.conflictBehavior': 'rename',
      }),
    });
    if (!createRes.ok) throw new Error(`Create folder failed: ${await createRes.text()}`);
    const created = await createRes.json();
    cursorId = created.id;
  }
  return cursorId; // itemId of the final folder
}

async function chunkedUpload(accessToken, driveId, folderPath, fileName, fileBuffer, mime = 'audio/mpeg') {
  // Create upload session at full path (folders must already exist)
  const itemPath = `${folderPath}/${fileName}`;
  const sessRes = await fetch(
    `${GRAPH}/drives/${driveId}/root:/${encodeURI(itemPath)}:/createUploadSession`,
    {
      method: 'POST',
      headers: { Authorization: `Bearer ${accessToken}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({ item: { '@microsoft.graph.conflictBehavior': 'replace' } }),
    }
  );
  if (!sessRes.ok) throw new Error(`Create upload session failed: ${await sessRes.text()}`);
  const session = await sessRes.json();

  const CHUNK = 2 * 1024 * 1024; // 2MB
  let start = 0;
  while (start < fileBuffer.length) {
    const end = Math.min(start + CHUNK, fileBuffer.length);
    const chunk = fileBuffer.subarray(start, end);
    const put = await fetch(session.uploadUrl, {
      method: 'PUT',
      headers: {
        'Content-Length': String(chunk.length),
        'Content-Range': `bytes ${start}-${end - 1}/${fileBuffer.length}`,
        'Content-Type': mime,
      },
      body: chunk,
    });
    if (!put.ok && put.status !== 202) {
      throw new Error(`Chunk upload failed ${put.status}: ${await put.text()}`);
    }
    if (put.status === 200 || put.status === 201) {
      // Final response returns the DriveItem
      return put.json();
    }
    start = end;
  }
  throw new Error('Upload session ended unexpectedly without final item');
}

async function createAnonViewLink(accessToken, driveId, itemId) {
  // Optional: requires tenant policy allowing anonymous links
  const res = await fetch(`${GRAPH}/drives/${driveId}/items/${itemId}/createLink`, {
    method: 'POST',
    headers: { Authorization: `Bearer ${accessToken}`, 'Content-Type': 'application/json' },
    body: JSON.stringify({ type: 'view', scope: 'anonymous' }),
  });
  if (!res.ok) throw new Error(`Create link failed: ${await res.text()}`);
  const data = await res.json();
  return data?.link?.webUrl || null;
}

export async function POST(req) {
  try {
    // Must be multipart/form-data
    const contentType = req.headers.get('content-type') || '';
    if (!contentType.toLowerCase().includes('multipart/form-data')) {
      return NextResponse.json(
        { ok: false, error: 'Invalid content type. Use multipart/form-data.' },
        { status: 400, headers: { 'Cache-Control': 'no-store' } }
      );
    }

    const form = await req.formData();
    const file = form.get('file');
    const vendorNameInput = form.get('vendorName') || form.get('vendor') || form.get('name');

    if (!file || typeof file === 'string') {
      return NextResponse.json(
        { ok: false, error: 'No file received. Field name must be "file".' },
        { status: 400, headers: { 'Cache-Control': 'no-store' } }
      );
    }

    const filename = file.name || 'audio.mp3';
    const mime = file.type || 'application/octet-stream';
    const size = file.size ?? 0;

    const lowerName = filename.toLowerCase();
    const looksLikeMp3 = lowerName.endsWith('.mp3');
    const mimeOk = ALLOWED_MIME.has(mime);

    if (!looksLikeMp3 && !mimeOk) {
      return NextResponse.json(
        { ok: false, error: 'Audio must be an .mp3 file.' },
        { status: 400, headers: { 'Cache-Control': 'no-store' } }
      );
    }

    if (size > MAX_BYTES) {
      return NextResponse.json(
        { ok: false, error: 'Audio file must be 10MB or smaller.' },
        { status: 413, headers: { 'Cache-Control': 'no-store' } } // 413 = payload too large
      );
    }

    const bytes = new Uint8Array(await file.arrayBuffer());

    // Auth for Microsoft Graph
    const { access_token } = await getGraphToken();

    // Build folder path: Vendors/<VendorName>/Recordings/YYYY-MM
    const now = new Date();
    const yyyy = now.getFullYear();
    const mm = String(now.getMonth() + 1).padStart(2, '0');

    const baseRoot = process.env.ONEDRIVE_BASE_FOLDER || 'Vendors';
    const vendorName = safeSegment(vendorNameInput || 'Unknown Vendor');
    const folderPath = `${safeSegment(baseRoot)}/${vendorName}/Recordings/${yyyy}-${mm}`;

    // Ensure folder chain exists
    await ensureFolderPath(access_token, process.env.ONEDRIVE_DRIVE_ID, folderPath);

    // File name: <VendorName>-YYYYMMDD-HHMMSS.mp3
    const ts =
      `${yyyy}${mm}${String(now.getDate()).padStart(2, '0')}-` +
      `${String(now.getHours()).padStart(2, '0')}${String(now.getMinutes()).padStart(2, '0')}${String(now.getSeconds()).padStart(2, '0')}`;
    const cleanBase = safeSegment(vendorName) || 'recording';
    const finalName = (looksLikeMp3 ? lowerName : `${cleanBase}-${ts}.mp3`).replace(/\s+/g, '-');

    // Upload to OneDrive (chunked)
    const item = await chunkedUpload(
      access_token,
      process.env.ONEDRIVE_DRIVE_ID,
      folderPath,
      finalName,
      bytes,
      'audio/mpeg'
    );

    // Try to produce an anonymous view link; fall back to webUrl
    let publicUrl = null;
    try {
      publicUrl = await createAnonViewLink(access_token, process.env.ONEDRIVE_DRIVE_ID, item.id);
    } catch {
      // Tenant may block anon links; that's fineâ€”we'll return signed-in webUrl
    }

    return NextResponse.json(
      {
        ok: true,
        // Use a normal https URL to keep Zapier happy
        audioUrl: publicUrl || item.webUrl,
        file: { id: item.id, name: item.name, webUrl: item.webUrl },
        vendorFolder: folderPath,
        vendorName,
      },
      { status: 200, headers: { 'Cache-Control': 'no-store' } }
    );
  } catch (err) {
    console.error('vendor-audio upload error:', err);
    return NextResponse.json(
      { ok: false, error: 'Audio upload failed. Please try again.' },
      { status: 500, headers: { 'Cache-Control': 'no-store' } }
    );
  }
}
